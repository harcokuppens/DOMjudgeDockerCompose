#!/bin/bash

# --- Script info  ---
SCRIPTDIR=$(cd -- "$(dirname -- "${BASH_SOURCE[0]}")" &>/dev/null && pwd)
SCRIPTNAME=$(basename "$0")

# --- Default Configuration ---
# Number of unique backups to keep
NUM_TO_KEEP=20
# the default backup dir is a folder 'backups' in the current working directory
BACKUP_DIR="$PWD/backups/"

# --- Usage/help function ---
usage() {
    cat <<EOF
NAME 
    $SCRIPTNAME - Rolling backup of a MariaDB database

SYNOPSIS 
    $SCRIPTNAME [OPTIONS] DATABASE

OPTIONS 
  --user USER_NAME, -u USER_NAME
                     The MariaDB user name to use when connecting to the server.
                     (default: current system user's name)
  --password PASSWORD, -p PASSWORD
                     The password to use when connecting to the server. 
  -H HOSTNAME, --host HOSTNAME 
                     The hostname of the MariaDB server.
                     If neither a container name nor a host name is provided, 
                     then localhost is used as host name. 
  -C CONTAINER, --container CONTAINER
                     The name of the Docker container running MariaDB 
                     If neither a container name nor a host name is provided, 
                     then localhost is used as host name.                         
  -d, --dir DIR      Set backup directory (default: ./backups/)
  -k, --keep NUM     Number of unique backups to keep (default: 20)
  -c, --checksum     Create checksums (default: true if -r option used, false otherwise)
                     The checksums are stored in a file next to the backup file
                     with the same name but with a .sha256 extension.

  -e, --exclude-tables-in-checksum TABLES
                     Comma separated list of tables to exclude from checksum calculation
                     (default: none)
  -r, --remove-eq-prev      
                     Remove previous backup if checksum equivalent with new backup.
                     This option implies the -c option.
  -h, --help         Show this help message and exit



DESCRIPTION
  This script creates rolling backups of a mariadb database. It uses an
  external 'mariadb-backup' script for creating a good hashable backup,
  and a 'mariadb-backup-checksum' script for a configurable special 
  checksum. The backups are stored in the specified directory.
  
  By default the script creates a new backup every time it is run,
  and keeps NUM_TO_KEEP backups. If more then NUM_TO_KEEP backups
  exist, the oldest are deleted.  

  Using the option -c, the script creates checksums for each backup.
  This can be helpful to verify the integrity of the backups.
  The mariadb-restore-backup script use these checksums to verify
  the integrity of a backup before restoring it.
  
  To save more space, the script can optimize the backup storage
  by removing the previous backup if it is equivalent to the new
  backup. Then only when the database has really changed a new backup
  is kept. This is done using the -r option. This option implies 
  the -c option.
  
  Because some tables in the database may contain frequently changing
  timestamp or logging data which is not essential for detecting changes
  in the main data, the checksum calculation can be configured to ignore
  such tables. This is done by providing a comma separated list of
  tables to exclude from the checksum calculation using the -e option.

  When using the -r option and a new backup is created, its checksum 
  is compared to the most recent one:
  
  - If checksums are different, the new backup is added to the history,
    and the oldest is discarded to maintain the specified number of
    backups.
  
  - If checksums are identical, the new backup replaces the old one.
    This ensures that the latest version of the database is always
    kept, even if the main data hasn't changed. This is important
    because configuration data in the tables ignored by the checksum may
    have been updated.

EXAMPLES

  In below examples we assume the script is called daily from cron.

    $SCRIPTNAME -r -d /tmp/backups -k 10 
      Daily makes a new backup in /tmp/backups. It does keep 10 unique backups,
      where equivalent backups are discarded. So we could have backups older
      then 10 days.

    $SCRIPTNAME 
      Make a daily backup. By default the command keeps 20 backups, one per
      day until 20 days back. Where with -r option in case of equivalent
      backups we could  have backups older then 20 days.

EOF
}

# --- log and error functions  ---
info() {
    echo "$(date +%Y-%m-%d\ %H:%M:%S) - $SCRIPTNAME - INFO  - $*" 1>&2
}
error() {
    echo "$(date +%Y-%m-%d\ %H:%M:%S) - $SCRIPTNAME - ERROR - $*" 1>&2
}

# --- Parse arguments ---

USERNAME=""
PASSWORD=""
HOST=""
CONTAINER=""
REMOVE_EQUIVALENT_PREV="false"
CREATE_CHECKSUM="false"
EXCLUDE_TABLES=""
while [[ "$1" =~ ^- && ! "$1" == "--" ]]; do
    case "$1" in
    -u | --user)
        USERNAME="$2"
        shift 2
        ;;
    -p | --password)
         PASSWORD="$2"
        shift 2
        ;;
    -H | --host)
        HOST="$2"
        shift 2
        ;;
    -C | --container)
        CONTAINER="$2"
        shift 2
        ;;
    -d | --dir)
        BACKUP_DIR="$2"
        shift 2
        ;;
    -k | --keep)
        NUM_TO_KEEP="$2"
        shift 2
        ;;
    -c | --checksum)
        # enable creation of checksum
        CREATE_CHECKSUM="true"
        shift 1
        ;;
    -r | --remove-eq-prev)
        REMOVE_EQUIVALENT_PREV="true"
        shift 1
        ;;
    -e | --exclude-tables-in-checksum)
        EXCLUDE_TABLES="$2"
        shift 2
        ;;
    -h | --help)
        usage
        exit 0
        ;;
    *)
        error "Unknown option: $1"
        usage >&2
        exit 1
        ;;
    esac
done

if [[ "$REMOVE_EQUIVALENT_PREV" == "true" ]]; then
    CREATE_CHECKSUM="true"
fi

DATABASE="$1"
if [[ -z "$DATABASE" ]]; then
    error "No database name provided."
    usage >&2
    exit 1
fi
NAME="$DATABASE"

# --- Cleanup old backups ---

# The following command keeps the latest N unique backups by deleting the oldest ones.
# note: we list files then sort them by name with youngest first, then skip first NUM_TO_KEEP lines,
#       and delete remaining ( NUM_TO_KEEP youngest remain)
# note: we use the fact that the filename contains a timestamp in format YYYYMMDD_HHMMSS
#       so sorting by name is equivalent to sorting by date.
cleanup_old_backups() {
    # Initialize an empty array
    files_to_delete=()

    # Explanation of the command:
    #   sort -r       : sort in reverse order (higher numbers first =>  newest first)
    #   tail -n +NUM  : to output lines starting with line NUM to end
    # -> if we want to only keep NUM_TO_KEEP newest files, we need to keep first NUM_TO_KEEP lines,
    #    and remove the NUM_TO_KEEP+1 and following lines.
    # -> so the command to get the files to delete:
    #      find "$BACKUP_DIR" -maxdepth 1 -name "${NAME}-2*.sql.gz" | sort -r | tail -n +"$((NUM_TO_KEEP + 1))"
    #
    # Use a while loop to read in these lines and append them to the array
    while IFS= read -r file; do
        files_to_delete+=("$file")
    done < <(find "$BACKUP_DIR" -maxdepth 1 -name "${NAME}-2*.sql.gz" | sort -r | tail -n +"$((NUM_TO_KEEP + 1))")

    # Now you can use the array as before
    for file in "${files_to_delete[@]}"; do
        rm "$file"
        if [[ -f "$file.sha256" ]]; then
            rm "$file.sha256"
        fi
        info "Deleted old backup: $file"
    done
}

# --- Discard equivalent backups logic ---

# checksum comparison to discard equivalent backups.
discard_equivalent_previous_backup() {

    # Compare with last backup using hashes of the new and last backups
    # and if identical discard the new backup

    # Check for the existence of the hash file next to the last backup
    # note: for the new backup we always create the hash file in this script before calling this function
    if [[ ! -f "$LAST_BACKUP.sha256" ]]; then
        info "Previous backup's hash file not found. Generating it now in  $(basename "$LAST_BACKUP.sha256")"
        "$SCRIPTDIR"/mariadb-backup-checksum --exclude-tables "$EXCLUDE_TABLES" "$LAST_BACKUP" >"$LAST_BACKUP.sha256"
    fi

    # Read the stored hash of the last backup
    LAST_HASH=$(cat "$LAST_BACKUP.sha256")
    # Read the hash of the new temporary dump file
    NEW_HASH=$(cat "$DUMPFILE.sha256")
    # Compare hashes of the new and last backups
    if [[ "$LAST_HASH" == "$NEW_HASH" ]]; then
        # The new backup is identical to the last one, so we discard previous backup.
        # Reasons for this policy:
        # 1) In the checksum we could have excluded some tables because timestamp none relevant changes,
        #    however there could be still some small changes which may be important, so we prefer the newer
        #    above the older backup.
        # 2) If we look at the folder we will always see a recent backup, so we immediately see if something
        #    is wrong if there is no recent backup!
        rm "$LAST_BACKUP" "$LAST_BACKUP.sha256"
        info "New backup equivalent to previous."
        info "Deleted previous backup: $(basename "$LAST_BACKUP")"
    else
        # The database has changed, so we keep the previous backup.
        info "Database state changed, so we keep previous backup."
    fi
}

# --- Setup ---

# Generate a timestamp for this run. We use this for both the temporary and final filenames.
# The format YYYYMMDD_HHMMSS is good for sorting.
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
DUMPFILE="$BACKUP_DIR/${NAME}-${TIMESTAMP}.sql.gz"
# Temporary file used during the backup process
TEMP_DUMPFILE="$BACKUP_DIR/temp_${NAME}-${TIMESTAMP}.sql.gz"

# find the last backup file (if any), before doing the new backup
LAST_BACKUP=$(find "$BACKUP_DIR" -maxdepth 1 -name "${NAME}-2*.sql.gz" | sort -r | head -n 1)

# --- Main Logic  ---

# Log the start of the backup process
info "Backup started in $BACKUP_DIR"

# Dump database safely using options for a consistent output
# Note: your script calls an external 'backup' script
#       which itself outputs info and error messages.
#       The backup script creates the backup folder
#       if it does not exist.
"$SCRIPTDIR"/mariadb-backup --user "$USERNAME" --password "$PASSWORD" --host "$HOST" --container "$CONTAINER" "$DATABASE" "$TEMP_DUMPFILE"

# # test lines to simulate a backup
# # - changed content
#echo "test $RANDOM" | gzip >"$TEMP_DUMPFILE"
# # - nothing changed
#cp "$LAST_BACKUP" "$TEMP_DUMPFILE"

errorcode="$?"
if [[ "$errorcode" != "0" ]]; then
    error "Backup failed with error code '$errorcode'."
    exit $errorcode
fi

# If we reach here, it means the backup was successful.
mv "$TEMP_DUMPFILE" "$DUMPFILE"
info "Backup saved as $(basename "$DUMPFILE")."

# create checksum of new backup if requested
if [[ "$CREATE_CHECKSUM" == "true" ]]; then
    info "Generating hash of backup in $(basename "$DUMPFILE.sha256")"
    "$SCRIPTDIR"/mariadb-backup-checksum --exclude-tables "$EXCLUDE_TABLES" "$DUMPFILE" >"$DUMPFILE.sha256"
fi

# remove previous backup if equivalent to new backup and if requested
if [[ -f "$LAST_BACKUP" && "$REMOVE_EQUIVALENT_PREV" == "true" ]]; then
    discard_equivalent_previous_backup
fi

# cleanup old backups if we have more then NUM_TO_KEEP backups
cleanup_old_backups
